
<!doctype html>
<html lang="en"> <head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dr. Mariam ‚Äî AI Pharmacy Tutor (Animated)</title>
  <meta name="description" content="AI powered pharmacy tutor with animated doctor avatar" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>

  <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.159.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://unpkg.com/three@0.159.0/examples/js/controls/OrbitControls.js"></script>

  <script src="https://unpkg.com/pdfjs-dist@3.9.179/build/pdf.min.js"></script>
  <script>
    // Set worker source for pdf.js
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://unpkg.com/pdfjs-dist@3.9.179/build/pdf.worker.min.js`;
  </script>

  <style>
    /* Light mode defaults */
    :root { 
      --bg: #f0f4f9; 
      --muted: rgba(0,0,0,0.6); 
      --avatar-bg-start: #e0e8f0;
      --avatar-bg-end: #f0f4f9;
      --select-bg: #ffffff;
    }
    html,body,#app { height:100%; }
    body { 
      font-family: 'Inter', sans-serif; 
      background: var(--bg); 
      color: #1f2937; 
      margin:0; 
      transition: background 0.3s, color 0.3s;
    }
    .glass { 
      background: rgba(255,255,255,0.4); 
      border: 1px solid rgba(0,0,0,0.06); 
      backdrop-filter: blur(8px); 
      transition: background 0.3s, border 0.3s;
    }
    .avatarBox { 
      width:100%; height:360px; border-radius:14px; overflow:hidden; position:relative; 
      background: linear-gradient(180deg, var(--avatar-bg-start), var(--avatar-bg-end));
      transition: background 0.3s;
    }
    .avatarOverlay { position:absolute; left:0; right:0; top:0; bottom:0; display:flex; align-items:flex-end; justify-content:center; pointer-events:none; }
    .btn { padding: 10px 14px; border-radius:10px; font-weight:600; cursor:pointer; transition: background 0.3s, color 0.3s, border 0.3s; }
    .btn-primary { background: linear-gradient(90deg,#667eea,#f857a6); color: white; }
    .chip { background: rgba(0,0,0,0.04); padding:6px 10px; border-radius:999px; font-weight:600; transition: background 0.3s; }
    .msg-me { background: linear-gradient(90deg,#667eea,#764ba2); color:#fff; margin-left:auto; padding:10px; border-radius:12px; max-width:85%; word-wrap:break-word; }
    .msg-ai { background: rgba(0,0,0,0.04); color:#1f2937; margin-right:auto; padding:10px; border-radius:12px; max-width:85%; word-wrap:break-word; transition: background 0.3s, color 0.3s; }
    .msg-ai code { background: rgba(0,0,0,0.1); padding: 2px 5px; border-radius: 4px; font-family: monospace; }
    .msg-ai ul, .msg-ai ol { margin-left: 20px; padding-left: 5px; }
    .msg-ai li { margin-bottom: 4px; }
    .scroll-y { max-height: 36vh; overflow-y:auto; overflow-x: hidden; }
    .small { font-size:12px; color:#6b7280; transition: color 0.3s; }
    .hidden { display:none; }
    footer { color:#6b7280; font-size:12px; text-align:center; padding:12px 0; transition: color 0.3s; }
    select { background-color: var(--select-bg); }

    /* Dark mode overrides */
    .dark:root { 
      --bg: #0a0e27; 
      --muted: rgba(255,255,255,0.6); 
      --avatar-bg-start: #081026;
      --avatar-bg-end: #0e1531;
      --select-bg: #0a0e27;
    }
    .dark body { 
      background: radial-gradient( circle at 10% 10%, rgba(120,119,198,0.06), transparent 10% ), linear-gradient(#07102b, #0a0e27); 
      color:#fff; 
    }
    .dark .glass { 
      background: rgba(255,255,255,0.03); 
      border: 1px solid rgba(255,255,255,0.06); 
    }
    .dark .chip { background: rgba(255,255,255,0.04); }
    .dark .msg-ai { background: rgba(255,255,255,0.04); color:#fff; }
    .dark .msg-ai code { background: rgba(0,0,0,0.3); }
    .dark .small { color:#cbd5e1; }
    .dark footer { color:#9aa7ff; }
    
    @media (max-width: 900px) {
      .flex-lg { display:block; }
      .avatarBox { height:260px; }
    }
  </style>
</head>
<body class="text-gray-900 dark:text-white">
  <div id="app" class="p-4 max-w-6xl mx-auto">
    <div class="flex items-center gap-4 mb-4">
      <div style="width:64px;height:64px;border-radius:12px;background:linear-gradient(90deg,#667eea,#f857a6);display:flex;align-items:center;justify-content:center;font-size:24px">üíä</div>
      <div>
        <h1 class="text-2xl font-semibold">Dr. Mariam ‚Äî AI Pharmacy Tutor</h1>
        <div class="small">Animated doctor + voice practice ‚Ä¢ Flashcards ‚Ä¢ Local memory</div>
      </div>
      <div class="ml-auto flex items-center gap-2">
        <div class="chip">AI: <span id="ai-status">Ready</span></div>
        <button id="themeToggle" class="btn glass">Dark üåô</button>
      </div>
    </div>

    <div class="grid grid-cols-12 gap-6 flex-lg">
      <div class="col-span-12 lg:col-span-4">
        <div class="glass p-4 mb-4 rounded-lg">
          <div class="text-lg font-semibold">Create / Upload</div>
          <div class="mt-3">
            <label class="small">Set name</label>
            <input id="setName" class="w-full mt-1 p-2 rounded-lg bg-white dark:bg-transparent border border-gray-300 dark:border-white/5 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400" placeholder="e.g., CV Pharmacology" />
          </div>
          <div class="mt-3 grid grid-cols-2 gap-2">
            <input id="numQuestions" type="number" min="5" max="50" value="12" class="w-full p-2 rounded-lg border border-gray-300 dark:border-white/5 bg-white dark:bg-transparent text-gray-900 dark:text-white" />
            <select id="difficulty" class="w-full p-2 rounded-lg border border-gray-300 dark:border-white/5 text-gray-900 dark:text-white">
              <option value="intermediate">Intermediate</option>
              <option value="advanced" selected>Advanced</option>
              <option value="expert">Expert</option>
            </select>
          </div>

          <div class="mt-3">
            <label class="small">Upload material (PDF / TXT)</label>
            <input id="fileInput" type="file" accept=".pdf,.txt" class="mt-1 w-full text-sm" />
            <div id="uploadPreview" class="small mt-2"></div>
            <div class="mt-3 flex gap-2">
              <button id="generateFromText" class="btn btn-primary flex-1">Generate Flashcards</button>
              <button id="uploadAndExtract" class="btn glass">Extract</button>
            </div>
          </div>

          <div class="mt-4">
            <div class="small mb-1">Quick Actions</div>
            <div class="flex gap-2">
              <button id="quickFlash" class="btn glass">AI Flashcards</button>
              <button id="clearLocal" class="btn glass">Clear Data</button>
            </div>
          </div>
        </div>

        <div class="glass p-4 rounded-lg">
          <div class="flex items-center justify-between mb-2">
            <div class="small">Local Study Sets (<span id="local-count">0</span>)</div>
            <div class="flex gap-2">
              <button id="exportSets" class="btn glass">Export</button>
              <button id="importSets" class="btn glass">Import</button>
              <input id="importFile" type="file" accept="application/json" class="hidden" />
            </div>
          </div>
          <div id="setsList" class="space-y-2 max-h-64 overflow-auto"></div>
        </div>
      </div>

      <div class="col-span-12 lg:col-span-8">
        <div class="glass p-4 mb-4 rounded-lg">
          <div class="flex gap-2 items-center mb-3">
            <h2 class="text-lg font-semibold">Dr. Mariam ‚Äî Speak & Practice</h2>
            <div class="ml-auto flex items-center gap-2">
              <div class="small">Learna mode</div>
              <button id="micBtn" class="btn">üéôÔ∏è</button>
              <button id="toggleContinuous" class="btn glass">Continuous: Off</button>
              <button id="ttsBtn" class="btn">üîä</button>
              <button id="clearChat" class="btn glass">Clear</button>
            </div>
          </div>

          <div class="avatarBox mb-3" id="avatarBox">
            <canvas id="avatarCanvas" style="width:100%;height:100%;display:block"></canvas>
            <div class="avatarOverlay">
              <div style="pointer-events:none; text-align:center; margin-bottom:18px;">
                <div id="avatarName" style="font-weight:700">Dr. Mariam</div>
                <div class="small">Your AI clinical tutor</div>
              </div>
            </div>
          </div>

          <div id="chatWindow" class="scroll-y p-3 rounded-lg bg-gray-100 dark:bg-black/10 space-y-3" aria-live="polite"></div>

          <div class="mt-3 flex gap-2">
            <input id="chatInput" class="flex-1 p-3 rounded-lg bg-white dark:bg-transparent border border-gray-300 dark:border-white/5 text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400" placeholder="Press Enter to send or practice speaking..." />
            <button id="sendBtn" class="btn btn-primary">Send</button>
          </div>
        </div>

        <div class="glass p-4 rounded-lg">
          <div class="flex items-center justify-between">
            <h3 class="text-lg font-semibold">Study Flashcards</h3>
            <div class="small">AI explanation appears under each card</div>
          </div>

          <div id="cardsArea" class="mt-4">
            <div id="cardEmpty" class="small text-gray-400 dark:text-gray-400">No flashcards. Generate or load a set.</div>
            <div id="cardView" class="hidden">
              <div id="cardQuestion" class="p-6 bg-gray-100 dark:bg-white/6 rounded-xl text-xl mb-4"></div>
              <div id="cardAnswer" class="p-4 bg-gray-200 dark:bg-white/5 rounded-lg hidden"></div>
              <div id="cardExplanation" class="mt-3 p-3 bg-gray-100 dark:bg-white/6 rounded-lg hidden"></div>
              <div class="flex gap-2 mt-3">
                <button id="prevCard" class="btn glass">‚Üê Prev</button>
                <button id="flipCard" class="btn btn-primary">Show Answer</button>
                <button id="nextCard" class="btn glass">Next ‚Üí</button>
                <button id="saveProgress" class="btn glass ml-auto">Save Progress</button>
              </div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <footer>Built with ‚ô• ‚Äî <strong>Paste your API key in the code to get started.</strong></footer>
  </div>

<script>
/* ============================================================
  AI-PHARMACY-TUTOR SCRIPT
============================================================ */

/* ============================================================
   üîë üîë üîë PASTE YOUR API KEY HERE üîë üîë üîë
   ============================================================ */

const OPENAI_API_KEY = "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"; 

/* ============================================================
   (Make sure to replace the "YOUR_API_KEY_HERE" string)
   ============================================================ */


/* --- Models / settings --- */
const MODEL_CHAT = "gpt-4o"; // Using the highest-end model

/* --- Basic DOM refs --- */
const aiStatus = document.getElementById("ai-status");
const chatWindow = document.getElementById("chatWindow");
const chatInput = document.getElementById("chatInput");
const sendBtn = document.getElementById("sendBtn");
const micBtn = document.getElementById("micBtn");
const ttsBtn = document.getElementById("ttsBtn");
const toggleContinuousBtn = document.getElementById("toggleContinuous");
const clearChatBtn = document.getElementById("clearChat");
const themeToggleBtn = document.getElementById("themeToggle");
const htmlEl = document.documentElement;

const fileInput = document.getElementById("fileInput");
const uploadPreview = document.getElementById("uploadPreview");
const generateBtn = document.getElementById("generateFromText");
const uploadBtn = document.getElementById("uploadAndExtract");
const quickFlashBtn = document.getElementById("quickFlash");
const clearLocalBtn = document.getElementById("clearLocal");
const setsList = document.getElementById("setsList");
const localCount = document.getElementById("local-count");
const setNameInput = document.getElementById("setName");
const numQuestionsInput = document.getElementById("numQuestions");
const difficultyInput = document.getElementById("difficulty");
const cardEmpty = document.getElementById("cardEmpty");
const cardView = document.getElementById("cardView");
const cardQuestion = document.getElementById("cardQuestion");
const cardAnswer = document.getElementById("cardAnswer");
const cardExplanation = document.getElementById("cardExplanation");
const flipCard = document.getElementById("flipCard");
const prevCard = document.getElementById("prevCard");
const nextCard = document.getElementById("nextCard");
const saveProgressBtn = document.getElementById("saveProgress");

/* --- Local storage keys --- */
const LS_THEME = "aiph_theme_v1";
const LS_SETS = "aiph_sets_v1";
// const LS_CHAT = "aiph_chat_v1"; // Removed for privacy
const LS_LAST_EXTRACT = "aiph_last_extracted";
const LS_EXPLANATIONS = "aiph_explanations_v1";
const LS_PROGRESS = "aiph_progress_v1";

/* --- App state --- */
let localSets = JSON.parse(localStorage.getItem(LS_SETS) || "[]");
let chatHistory = []; // ‚ú® CHANGED: Chat history is no longer loaded from storage.
let currentCards = [];
let currentIndex = 0;
let continuousRecognition = false;

/* ---------- Utility helpers ---------- */
function setAIStatus(t) { aiStatus.innerText = t; }
function scrollChatToBottom() { chatWindow.scrollTop = chatWindow.scrollHeight; }
function saveSets() { localStorage.setItem(LS_SETS, JSON.stringify(localSets)); refreshSetsUI(); }

// ‚ú® REMOVED: saveChat() function is no longer needed.

function escapeHtml(str){ return String(str).replace(/[&<>"]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[c])); }

function simpleMarkdown(text) {
  let html = escapeHtml(text);
  html = html.replace(/```([\s\S]*?)```/g, '<pre style="background:rgba(0,0,0,0.1); padding:8px; border-radius:6px; overflow-x:auto;"><code>$1</code></pre>');
  html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
  html = html.replace(/`(.*?)`/g, '<code>$1</code>');
  html = html.replace(/^\* (.*$)/gm, '<ul><li>$1</li></ul>');
  html = html.replace(/^\- (.*$)/gm, '<ul><li>$1</li></ul>');
  html = html.replace(/^(\d+)\. (.*$)/gm, '<ol start="$1"><li>$2</li></ol>');
  html = html.replace(/<\/ul>\s*<ul>/g, '');
  html = html.replace(/<\/ol>\s*<ol start="\d+">/g, '');
  html = html.replace(/\n/g, '<br>');
  html = html.replace(/<pre(.*?)><code><br>/g, '<pre$1><code>');
  html = html.replace(/<br><\/code><\/pre>/g, '</code></pre>');
  return html;
}

/* ---------- Theme Management ---------- */
function applyTheme(theme) {
  if (theme === 'dark') {
    htmlEl.classList.add('dark');
    themeToggleBtn.innerText = "Light ‚òÄÔ∏è";
  } else {
    htmlEl.classList.remove('dark');
    themeToggleBtn.innerText = "Dark üåô";
  }
}

themeToggleBtn.addEventListener("click", () => {
  const isDark = htmlEl.classList.contains('dark');
  const newTheme = isDark ? 'light' : 'dark';
  localStorage.setItem(LS_THEME, newTheme);
  applyTheme(newTheme);
});

/* ---------- Chat functions ---------- */
function refreshChatUI() {
  chatWindow.innerHTML = "";
  for (const m of chatHistory) {
    const el = document.createElement("div");
    el.className = m.role === "user" ? "msg-me" : "msg-ai";
    el.innerHTML = m.role === 'user' ? escapeHtml(m.content) : simpleMarkdown(m.content);
    chatWindow.appendChild(el);
  }
  scrollChatToBottom();
}

/**
 * ‚ú® CHANGED: Appends to in-memory chatHistory and UI, but no longer saves to localStorage.
 */
function appendChat(role, content, save=true) {
  // 'save' parameter now only controls if it's added to the *session* history
  if (save) {
    chatHistory.push({ role, content, time: Date.now() });
    // saveChat(); // ‚ú® REMOVED
  }
  const el = document.createElement("div");
  el.className = role === "user" ? "msg-me" : "msg-ai";
  el.innerHTML = role === 'user' ? escapeHtml(content) : simpleMarkdown(content);
  chatWindow.appendChild(el);
  scrollChatToBottom();
  return el;
}

/* ---------- OpenAI chat wrapper (browser call) ---------- */
async function openAIChat(messages, model=MODEL_CHAT, temperature=0.2, max_tokens=1000) {
  if (!OPENAI_API_KEY || OPENAI_API_KEY === "YOUR_API_KEY_HERE") {
    throw new Error("API Key is not set. Please paste your key into the script at the top where it says 'YOUR_API_KEY_HERE'.");
  }

  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type":"application/json",
      "Authorization": `Bearer ${OPENAI_API_KEY}`
    },
    body: JSON.stringify({
      model,
      messages,
      temperature,
      max_tokens
    })
  });

  if (!res.ok) {
    const errorData = await res.json();
    console.error("OpenAI API Error:", errorData);
    const errorMsg = errorData.error?.message || `HTTP Error: ${res.status}`;
    if (res.status === 401) {
      throw new Error("Error: Invalid OpenAI API Key. Please check the key you pasted into the code. \n\nNote: If you just added billing, it may take 5-10 minutes to activate.");
    }
    throw new Error(`OpenAI Error: ${errorMsg}`);
  }
  const j = await res.json();
  const reply = j.choices?.[0]?.message?.content ?? "";
  return { raw: j, reply };
}

/* Build conversation context */
function buildConversationContext() {
  const messages = [{ role: "system", content: "You are Dr. Mariam, an empathetic clinical pharmacy tutor and conversational partner. Provide clear, concise clinical explanations and practice spoken English when asked. Format your responses with markdown (bold, lists) for clarity." }];
  const last = chatHistory.slice(-6); 
  for (const m of last) {
    if (m.role === 'user' || m.role === 'assistant') {
       messages.push({ role: m.role, content: m.content });
    }
  }
  return messages;
}

async function handleSendMessage() {
  const text = chatInput.value.trim();
  if (!text) return;
  
  appendChat("user", text); // Adds to history and UI
  chatInput.value = "";
  setAIStatus("Thinking...");
  
  const loadingEl = appendChat("assistant", "Thinking... üí¨", false);
  
  try {
    const conv = buildConversationContext();
    const { reply } = await openAIChat(conv);
    loadingEl.remove();
    appendChat("assistant", reply);
    // speakText(reply); // ‚ú® REMOVED: No auto-speak
    setAIStatus("Ready");
  } catch (err) {
    loadingEl.remove();
    appendChat("assistant", "Error: " + (err.message || err), false);
    setAIStatus("Ready");
  }
}

sendBtn.addEventListener("click", handleSendMessage);
chatInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault(); // Prevent new line
    handleSendMessage();
  }
});

/**
 * ‚ú® CHANGED: Now only clears the in-memory 'chatHistory' array.
 */
clearChatBtn.addEventListener("click", ()=>{ 
  if(!confirm("Clear chat history?")) return; 
  chatHistory=[]; 
  // localStorage.removeItem(LS_CHAT); // ‚ú® REMOVED
  refreshChatUI(); 
});

/* ---------- Speech recognition (Learna mode) ---------- */
let recognition;
if ("webkitSpeechRecognition" in window || "SpeechRecognition" in window) {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  recognition = new SpeechRecognition();
  recognition.lang = "en-US";
  recognition.interimResults = false;
  recognition.maxAlternatives = 1;

  recognition.onresult = (e) => {
    const transcript = e.results[0][0].transcript;
    appendChat("user", transcript);
    
    // send automatically
    (async () => {
      setAIStatus("Thinking...");
      const loadingEl = appendChat("assistant", "Thinking... üí¨", false);
      
      try {
        const conv = buildConversationContext();
        const { reply } = await openAIChat(conv);
        
        loadingEl.remove();
        appendChat("assistant", reply);
        // speakText(reply); // ‚ú® REMOVED: No auto-speak
        setAIStatus("Ready");
      } catch (err) {
        loadingEl.remove();
        appendChat("assistant", "Error: " + (err.message || err), false);
        setAIStatus("Ready");
      }
    })();
  };

  recognition.onstart = () => {
    micBtn.classList.add("recording"); 
    micBtn.style.color = '#f857a6';
  };
  recognition.onend = () => {
    micBtn.classList.remove("recording");
    micBtn.style.color = '';
    if (continuousRecognition) {
      try { recognition.start(); } catch(e) { console.warn(e); }
    }
  };

  recognition.onerror = (e) => console.warn("Speech recognition error", e);

  micBtn.addEventListener("click", () => {
    try { 
      if (micBtn.classList.contains("recording")) {
        recognition.stop();
      } else {
        recognition.start(); 
      }
    } catch(e) { console.warn(e); }
  });

  toggleContinuousBtn.addEventListener("click", () => {
    continuousRecognition = !continuousRecognition;
    toggleContinuousBtn.innerText = `Continuous: ${continuousRecognition ? "On" : "Off"}`;
    if (continuousRecognition) try { recognition.start(); } catch(e) {}
    else try { recognition.stop(); } catch(e) {}
  });
} else {
  micBtn.disabled = true;
  toggleContinuousBtn.disabled = true;
  micBtn.title = "Speech recognition not supported";
}

/* ---------- TTS and avatar speaking hook ---------- */
function speakText(text) {
  if (!("speechSynthesis" in window)) return;
  try {
    const cleanText = text
      .replace(/\*\*(.*?)\*\*/g, '$1')
      .replace(/\*(.*?)\*/g, '$1')
      .replace(/`(.*?)`/g, '$1');
      
    const utter = new SpeechSynthesisUtterance(cleanText);
    utter.lang = "en-US";
    utter.rate = 1.0;
    utter.pitch = 1.0;
    
    let voices = speechSynthesis.getVoices();
    if (voices.length === 0) {
      speechSynthesis.onvoiceschanged = () => {
        voices = speechSynthesis.getVoices();
        const femaleVoice = voices.find(v => v.name.includes("Female") && v.lang.startsWith("en-US")) || voices.find(v => v.name.includes("Zira") || v.name.includes("Google US English"));
        if (femaleVoice) utter.voice = femaleVoice;
        triggerSpeech(utter);
      };
    } else {
        const femaleVoice = voices.find(v => v.name.includes("Female") && v.lang.startsWith("en-US")) || voices.find(v => v.name.includes("Zira") || v.name.includes("Google US English"));
        if (femaleVoice) utter.voice = femaleVoice;
        triggerSpeech(utter);
    }
  } catch (e) {
    console.warn("TTS error", e);
    if (window.avatarController) avatarController.setSpeaking(false);
  }
}
function triggerSpeech(utter) {
  if (window.avatarController) avatarController.setSpeaking(true);
  utter.onend = () => { if (window.avatarController) avatarController.setSpeaking(false); };
  utter.onerror = () => { if (window.avatarController) avatarController.setSpeaking(false); };
  speechSynthesis.cancel();
  speechSynthesis.speak(utter);
}
ttsBtn.addEventListener("click", () => {
  const last = chatHistory.slice().reverse().find(m => m.role === "assistant");
  if (last) speakText(last.content);
});

/* ---------- Chat persistence ---------- */
// ‚ú® REMOVED: loadInitialChat() function is no longer needed.

/* ---------- Flashcards generation (calls OpenAI) ---------- */
async function requestFlashcardsFromAI(text, numQuestions=12, difficulty="advanced") {
  const prompt = `You are an expert clinical pharmacy educator. From the source text provided, create ${numQuestions} exam-style flashcards for a ${difficulty} level. Return a JSON array ONLY. Each item must be {"id":1,"question":"...","answer":"...","explanation":"..."} Source text: """${text}"""`;
  const messages = [{ role:"system", content:"You generate exam-quality flashcards as strict JSON." }, { role:"user", content: prompt }];
  const { reply } = await openAIChat(messages, MODEL_CHAT, 0.1, 2000);
  let parsed = null;
  try { 
    parsed = JSON.parse(reply); 
  } catch(e) {
    const match = reply.match(/\[.*\]/s); // Try to find JSON array in text
    if (match) try { parsed = JSON.parse(match[0]); } catch(e2){ console.warn("parse fail", e2); }
  }
  if (!Array.isArray(parsed)) {
    console.warn("Failed to parse flashcards, got:", reply);
    return [{ id:1, question:"AI Error", answer:"Failed to parse JSON response from AI.", explanation: reply }];
  }
  return parsed.map((c, idx)=>({ id:c.id ?? idx+1, question:c.question ?? c.q ?? ("Q"+(idx+1)), answer:c.answer ?? c.a ?? "", explanation:c.explanation ?? "" }));
}

/* Generate flow (button) */
generateBtn.addEventListener("click", async () => {
  const name = setNameInput.value.trim() || `Set ${new Date().toLocaleString()}`;
  const n = Number(numQuestionsInput.value || 12);
  let text = localStorage.getItem(LS_LAST_EXTRACT) || "";
  if (!text) {
    text = prompt("Paste the source text to generate flashcards (or Cancel)");
    if (!text) return;
  }
  setAIStatus("Generating flashcards...");
  try {
    const cards = await requestFlashcardsFromAI(text, n, difficultyInput.value);
    const set = { name, cards, createdAt: new Date().toLocaleString() };
    localSets.unshift(set);
    saveSets();
    alert("Flashcards generated and saved locally.");
  } catch (err) {
    alert("Error: " + (err.message||err));
  } finally { setAIStatus("Ready"); }
});

/* ---------- PDF extraction client-side ---------- */
uploadBtn.addEventListener("click", async () => {
  const f = fileInput.files[0];
  if (!f) return alert("Select a file first.");
  uploadPreview.innerText = "Extracting text...";
  if (f.type === "application/pdf" || f.name.endsWith(".pdf")) {
    try {
      const ab = await f.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: ab }).promise;
      let txt = "";
      for (let i=1;i<=pdf.numPages;i++){
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        txt += content.items.map(it=>it.str).join(" ") + "\n\n";
      }
      localStorage.setItem(LS_LAST_EXTRACT, txt);
      uploadPreview.innerText = `Extracted text length: ${txt.length}`;
      alert("Extraction done - use Generate Flashcards.");
    } catch(e) {
      console.error(e); uploadPreview.innerText="Extraction failed"; alert("Extraction failed.");
    }
  } else {
    const txt = await f.text();
    localStorage.setItem(LS_LAST_EXTRACT, txt);
    uploadPreview.innerText = `Stored text length: ${txt.length}`;
    alert("Text stored locally.");
  }
});

/* ---------- Local sets UI ---------- */
function refreshSetsUI() {
  setsList.innerHTML = "";
  if (localSets.length === 0) {
    setsList.innerHTML = `<div class="small text-gray-400 p-2">No sets found.</div>`;
  }
  localSets.forEach((s,i) => {
    const div = document.createElement("div");
    div.className = "p-3 rounded-lg flex items-center justify-between bg-gray-100 dark:bg-black/10";
    div.innerHTML = `<div>
      <div class="font-semibold">${escapeHtml(s.name)}</div>
      <div class="small text-gray-400">${(s.cards?.length||0)} cards ‚Ä¢ ${s.createdAt}</div>
    </div>
    <div class="flex gap-2">
      <button class="btn glass" onclick="loadSet(${i})">Open</button>
      <button class="btn" onclick="deleteSet(${i})">Delete</button>
    </div>`;
    setsList.appendChild(div);
  });
  localCount.innerText = localSets.length;
}
window.loadSet = function(i) {
  const s = localSets[i];
  if (!s) return;
  currentCards = s.cards;
  currentIndex = 0;
  showCard();
};
window.deleteSet = function(i) {
  if (!confirm("Delete this set?")) return;
  localSets.splice(i,1);
  saveSets();
};

/* Export/Import */
document.getElementById("exportSets").addEventListener("click", () => {
  if (localSets.length === 0) return alert("No sets to export.");
  const blob = new Blob([JSON.stringify(localSets,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a"); a.href=url; a.download=`sets_DrMariam_${Date.now()}.json`; a.click(); URL.revokeObjectURL(url);
});
document.getElementById("importSets").addEventListener("click", ()=> document.getElementById("importFile").click());
document.getElementById("importFile").addEventListener("change", async (e)=> {
  const f = e.target.files[0]; if(!f) return;
  const text = await f.text();
  try {
    const arr = JSON.parse(text);
    if (!Array.isArray(arr)) throw new Error("Invalid format");
    if (arr.length > 0 && (!arr[0].name || !arr[0].cards)) {
      throw new Error("File does not seem to be a valid set.");
    }
    localSets = arr.concat(localSets);
    saveSets();
    alert(`Imported ${arr.length} sets.`);
  } catch(err) { alert("Import error: "+err.message); }
  e.target.value = null;
});

/* Clear local */
clearLocalBtn.addEventListener("click", ()=> {
  if (!confirm("Clear ALL local sets and flashcard data? (Chat history is already cleared on exit)")) return;
  localSets=[]; 
  localStorage.removeItem(LS_SETS); 
  localStorage.removeItem(LS_LAST_EXTRACT); 
  localStorage.removeItem(LS_EXPLANATIONS); 
  localStorage.removeItem(LS_PROGRESS);
  refreshSetsUI(); 
  currentCards = []; 
  showCard();
  alert("Cleared.");
});

/* ---------- Flashcard viewer & auto explanations ---------- */
function showCard() {
  if (!currentCards || currentCards.length===0) {
    cardEmpty.style.display = "block"; cardView.classList.add("hidden"); return;
  }
  cardEmpty.style.display = "none"; cardView.classList.remove("hidden");
  
  const c = currentCards[currentIndex];
  cardQuestion.innerText = `${currentIndex+1}/${currentCards.length}. ${c.question || c.q || "Question missing"}`;
  cardAnswer.innerText = c.answer || c.a || "Answer missing";
  cardAnswer.classList.add("hidden"); 
  cardExplanation.classList.add("hidden");
  cardExplanation.innerHTML = "";
  
  const exps = JSON.parse(localStorage.getItem(LS_EXPLANATIONS)||"{}");
  const key = `${(c.question || "").substring(0, 20)}_${(c.answer || "").substring(0, 20)}`;
  
  if (exps[key]) {
    cardExplanation.innerHTML = `<strong>AI Explanation:</strong><br>${exps[key]}`;
  }
  
  flipCard.innerText = "Show Answer";
}
flipCard.addEventListener("click", ()=> {
  const isHidden = cardAnswer.classList.contains("hidden");
  if (isHidden) { 
    cardAnswer.classList.remove("hidden"); 
    flipCard.innerText = "Hide Answer";
    
    cardExplanation.classList.remove("hidden");
    const key = `${(currentCards[currentIndex].question || "").substring(0, 20)}_${(currentCards[currentIndex].answer || "").substring(0, 20)}`;
    const exps = JSON.parse(localStorage.getItem(LS_EXPLANATIONS)||"{}");
    if (!exps[key]) {
      requestExplanationForCard(currentCards[currentIndex]);
    }
  }
  else { 
    cardAnswer.classList.add("hidden"); 
    cardExplanation.classList.add("hidden");
    flipCard.innerText = "Show Answer"; 
  }
});
prevCard.addEventListener("click", ()=> { if (currentIndex>0) currentIndex--; showCard(); });
nextCard.addEventListener("click", ()=> { if (currentIndex < currentCards.length-1) currentIndex++; showCard(); });
saveProgressBtn.addEventListener("click", ()=> {
  const p = JSON.parse(localStorage.getItem(LS_PROGRESS)||"{}"); 
  p.activeIndex = currentIndex; 
  localStorage.setItem(LS_PROGRESS, JSON.stringify(p)); 
  alert("Progress saved.");
});

/* Request card explanation and save */
async function requestExplanationForCard(card) {
  try {
    const exps = JSON.parse(localStorage.getItem(LS_EXPLANATIONS) || "{}");
    const key = `${(card.question || "").substring(0, 20)}_${(card.answer || "").substring(0, 20)}`;
    if (exps[key] && exps[key] !== "Loading...") return exps[key];
    
    exps[key] = "Loading...";
    localStorage.setItem(LS_EXPLANATIONS, JSON.stringify(exps));
    
    setAIStatus("Generating explanation...");
    cardExplanation.innerHTML = `<strong>AI Explanation:</strong><br>Generating...`;
    cardExplanation.classList.remove("hidden");

    const prompt = `You are a clinical pharmacy tutor. Explain this question and answer clearly for a student. Question: "${card.question}" Answer: "${card.answer}". Provide a short explanation (use markdown) and relevant clinical tips.`;
    const messages = [{ role:"system", content:"You are a helpful clinical pharmacy educator."}, { role:"user", content: prompt }];
    const { reply } = await openAIChat(messages, MODEL_CHAT, 0.2, 400);
    
    const formattedReply = simpleMarkdown(reply);
    exps[key] = formattedReply;
    localStorage.setItem(LS_EXPLANATIONS, JSON.stringify(exps));
    
    const currentCard = currentCards[currentIndex];
    const currentKey = `${(currentCard.question || "").substring(0, 20)}_${(currentCard.answer || "").substring(0, 20)}`;
    if (currentKey === key && !cardAnswer.classList.contains("hidden")) {
      cardExplanation.innerHTML = `<strong>AI Explanation:</strong><br>${formattedReply}`;
    }
    setAIStatus("Ready");
    return formattedReply;
  } catch (err) {
    console.warn("explain err", err); 
    setAIStatus("Ready");
    cardExplanation.innerHTML = `<strong>AI Explanation:</strong><br>Error loading explanation.`;
    const exps = JSON.parse(localStorage.getItem(LS_EXPLANATIONS) || "{}");
    const key = `${(card.question || "").substring(0, 20)}_${(card.answer || "").substring(0, 20)}`;
    delete exps[key];
    localStorage.setItem(LS_EXPLANATIONS, JSON.stringify(exps));
    return null;
  }
}

/* ---------- Init / boot ---------- */
function init() { 
  refreshSetsUI(); 
  refreshChatUI(); // This will just clear the chat area, as chatHistory is empty
  
  // Load theme
  const savedTheme = localStorage.getItem(LS_THEME) || 'light'; // Default to light
  applyTheme(savedTheme);
}
init();

/* ========================================================
  AVATAR: three.js scene, load GLB head+shoulders model,
  simple idle animations, blinking, and lip-movement
  while speaking (simulated).
  ======================================================== */

const canvas = document.getElementById("avatarCanvas");
const avatarController = (function(){
  const scene = new THREE.Scene();
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
  renderer.setSize(canvas.clientWidth, canvas.clientHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 0); // Transparent background
  
  const camera = new THREE.PerspectiveCamera(30, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
  camera.position.set(0, 1.4, 3.0);

  const light = new THREE.DirectionalLight(0xffffff, 1.0);
  light.position.set(5,10,7); scene.add(light);
  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8); // Brighter ambient
  hemi.position.set(0, 20, 0);
  scene.add(hemi);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 1.0, 0); // Look slightly higher
  controls.enableZoom = false; 
  controls.enablePan = false; 
  controls.enableRotate = false; // Disable all user controls
  controls.update();

  let model = null;
  let mixer = null; // For animations
  let clock = new THREE.Clock();

  /* ============================================================
     ü§ñ ü§ñ ü§ñ AVATAR MODEL LOCATION ü§ñ ü§ñ ü§ñ
     To change the avatar, replace the URL below with a link
     to your own .glb 3D model file.
     ============================================================ */
  const gltfLoader = new THREE.GLTFLoader();
  const glbUrl = "https://models.readyplayer.me/64f6f2a68ef336f03d68b6b1.glb";
  
  gltfLoader.load(glbUrl, (g) => {
    model = g.scene;
    model.scale.set(1.5, 1.5, 1.5);
    model.position.set(0, -1.6, 0); // Adjust position
    scene.add(model);

    // Find morph targets for blinking and speaking
    model.traverse((o) => {
      if (o.isSkinnedMesh && o.morphTargetDictionary) {
        if (o.morphTargetDictionary['eyesClosed']) {
          model.userData.blinkMesh = o;
        }
        if (o.morphTargetDictionary['mouthOpen']) {
          model.userData.speakMesh = o;
        }
      }
    });

    mixer = new THREE.AnimationMixer(model);
    
  }, undefined, (e)=> { console.warn("avatar load err", e); });

  let speaking = false;
  let speakIntensity = 0; // 0..1
  let blinkTimer = Math.random()*5+1;
  let blinkActive = false;
  
  function setSpeaking(flag) { 
    speaking = !!flag; 
  }
  
  function animate(now){
    requestAnimationFrame(animate);
    const dt = clock.getDelta();

    if (model) {
      // --- Blinking ---
      blinkTimer -= dt;
      let blinkValue = 0;
      if (blinkTimer <= 0.15 && !blinkActive) { // Start blink
        blinkActive = true;
      }
      
      if (blinkActive) {
         blinkValue = 1.0 - Math.abs(blinkTimer / 0.075); // 0 -> 1 -> 0
         if (blinkTimer <= -0.15) {
           blinkActive = false;
           blinkTimer = Math.random()*5+1; // Reset timer
           blinkValue = 0;
         }
      }
      
      if (model.userData.blinkMesh) {
        const blinkIndex = model.userData.blinkMesh.morphTargetDictionary['eyesClosed'];
        if (blinkIndex !== undefined) {
           model.userData.blinkMesh.morphTargetInfluences[blinkIndex] = blinkValue;
        }
      }

      // --- Speaking (Lip Sync) ---
      if (speaking) {
        speakIntensity = Math.min(1.0, speakIntensity + dt * 10.0);
      } else {
        speakIntensity = Math.max(0.0, speakIntensity - dt * 5.0);
      }
      
      if (model.userData.speakMesh) {
         const speakIndex = model.userData.speakMesh.morphTargetDictionary['mouthOpen'];
         if (speakIndex !== undefined) {
           const speakValue = (Math.sin(now / 80) + 1) / 2; // 0..1 range
           model.userData.speakMesh.morphTargetInfluences[speakIndex] = speakValue * speakIntensity * 0.8; // Max 80% open
         }
      }
      
      // --- Idle Body Sway ---
      const time = clock.getElapsedTime();
      model.rotation.y = Math.sin(time * 0.3) * 0.05;
      model.rotation.x = Math.sin(time * 0.5) * 0.02;
    }
    
    controls.update();
    renderer.render(scene, camera);
  }
  animate(performance.now());

  // responsive
  function resize() {
    const box = document.getElementById("avatarBox");
    if (!box) return;
    const w = box.clientWidth, h = box.clientHeight;
    renderer.setSize(w,h);
    camera.aspect = w/h; 
    camera.updateProjectionMatrix();
  }
  new ResizeObserver(resize).observe(document.getElementById("avatarBox"));
  resize(); // Initial call

  return {
    setSpeaking,
    isSpeaking: ()=> speaking
  };
})();

/* expose for other code */
window.avatarController = avatarController;

</script>
</body>
</html>




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
